package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
	"unicode"

	"golang.org/x/text/unicode/rangetable"
)

func main() {
	props := []string{"WordBreak", "GraphemeBreak"}

	for _, prop := range props {
		err := generate(prop)
		if err != nil {
			panic(err)
		}
	}
}

func generate(prop string) error {
	file, err := os.Open("gen/" + prop + "Property.txt")
	if err != nil {
		return err
	}
	b := bufio.NewReader(file)

	runesByCategory := map[string][]rune{}
	for {
		s, err := b.ReadString('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			return err
		}

		if len(s) == 0 {
			continue
		}

		if s[0] == '\n' || s[0] == '#' {
			continue
		}

		parts := strings.Split(s, ";")
		runes, err := getRuneRange(parts[0])
		if err != nil {
			return err
		}

		split2 := strings.Split(parts[1], "#")
		category := strings.TrimSpace(split2[0])

		runesByCategory[category] = append(runesByCategory[category], runes...)
	}

	rangeTablesByCategory := map[string]*unicode.RangeTable{}
	for category, runes := range runesByCategory {
		rangeTablesByCategory[category] = rangetable.New(runes...)
	}

	if prop == "WordBreak" {
		// Merged "macro" tables defined here: https://unicode.org/reports/tr29/#WB_Rule_Macros
		ALetter := rangeTablesByCategory["ALetter"]
		Hebrew_Letter := rangeTablesByCategory["Hebrew_Letter"]
		MidNumLet := rangeTablesByCategory["MidNumLet"]

		rangeTablesByCategory["AHLetter"] = rangetable.Merge(ALetter, Hebrew_Letter)
		rangeTablesByCategory["MidNumLetQ"] = rangetable.Merge(MidNumLet, rangetable.New('\''))
	}

	err = write(prop, rangeTablesByCategory)
	if err != nil {
		return err
	}

	return nil
}

func getRuneRange(s string) ([]rune, error) {
	s = strings.TrimSpace(s)
	hilo := strings.Split(s, "..")
	lo64, err := strconv.ParseInt("0x"+hilo[0], 0, 32)
	if err != nil {
		return nil, err
	}

	lo := rune(lo64)
	runes := []rune{lo}

	if len(hilo) == 1 {
		return runes, nil
	}

	hi64, err := strconv.ParseInt("0x"+hilo[1], 0, 32)
	if err != nil {
		return nil, err
	}

	hi := rune(hi64)
	if hi == lo {
		return runes, nil
	}

	// Skip first, inclusive of last
	for r := lo + 1; r <= hi; r++ {
		runes = append(runes, r)
	}

	return runes, nil
}

func write(prop string, rts map[string]*unicode.RangeTable) error {
	buf := &bytes.Buffer{}

	_, err := buf.WriteString("// generated by github.com/clipperhouse/uax29\n\n")
	if err != nil {
		return err
	}

	_, err = buf.WriteString("package " + strings.ToLower(prop) + "\n\n")
	if err != nil {
		return err
	}

	_, err = buf.WriteString("import \"unicode\"\n\n")
	if err != nil {
		return err
	}

	// Keep the write order stable
	categories := make([]string, 0, len(rts))
	for category := range rts {
		categories = append(categories, category)
	}
	sort.Strings(categories)

	for _, category := range categories {
		rt := rts[category]
		fmt.Fprintf(buf, "var %s = %#v\n\n", category, rt)
	}

	// Break up some lines for readability;
	// Better to create a custom printer for RangeTable, but meh for now
	source := buf.String()
	source = strings.ReplaceAll(source, "R16:", "\n\tR16:")
	source = strings.ReplaceAll(source, "[]unicode.Range16{", "[]unicode.Range16{\n\t")
	source = strings.ReplaceAll(source, ", unicode.Range16{", ",\n\tunicode.Range16{")
	source = strings.ReplaceAll(source, "\tunicode.Range16{", "\t\t{")
	source = strings.ReplaceAll(source, "}},", "},\n\t},")
	source = strings.ReplaceAll(source, "R32:", "\n\tR32:")
	source = strings.ReplaceAll(source, "[]unicode.Range32{", "[]unicode.Range32{\n\t")
	source = strings.ReplaceAll(source, ", unicode.Range32{", ",\n\tunicode.Range32{")
	source = strings.ReplaceAll(source, "\tunicode.Range32{", "\t\t{")
	source = strings.ReplaceAll(source, ", LatinOffset:0}", ",\n\tLatinOffset:0,\n}")
	source = strings.ReplaceAll(source, ", LatinOffset:1}", ",\n\tLatinOffset:1,\n}")
	source = strings.ReplaceAll(source, "Lo:", "")
	source = strings.ReplaceAll(source, "Hi:", "")
	source = strings.ReplaceAll(source, "Stride:", "")

	formatted, err := format.Source([]byte(source))
	if err != nil {
		return err
	}

	dst, err := os.Create(strings.ToLower(prop) + "/tables.go")
	if err != nil {
		return err
	}
	defer dst.Close()

	_, err = dst.Write([]byte(formatted))
	if err != nil {
		return err
	}

	return nil
}
